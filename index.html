<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Maze Runner</title>
  <style>
    /* Reset & Base Styles */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      font-family: Arial, sans-serif;
      color: #eee;
    }
    canvas {
      display: block;
      background: #222;
      border: 2px solid #444;
    }
    /* HUD (Heads-Up Display) */
    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 5px;
      font-size: 1.1em;
    }
    .hud div {
      margin-bottom: 5px;
    }
    /* Overlay styles for Start, Level Complete, and Game Over screens */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 0.5s ease;
      z-index: 100;
    }
    .hidden {
      opacity: 0;
      pointer-events: none;
    }
    .overlay h1 {
      font-size: 2.5em;
      margin-bottom: 20px;
    }
    .overlay p {
      font-size: 1.2em;
      margin: 10px 0;
      text-align: center;
    }
    .overlay button {
      padding: 10px 20px;
      font-size: 1.2em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #28a745;
      color: #fff;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- Heads-Up Display -->
  <div class="hud">
    <div>Level: <span id="levelDisplay">1</span></div>
    <div>Time: <span id="timerDisplay">10.0</span>s</div>
    <div>Score: <span id="scoreDisplay">0</span></div>
    <div>High Score: <span id="highScoreDisplay">0</span></div>
  </div>

  <!-- Start Screen Overlay -->
  <div id="startOverlay" class="overlay">
    <h1>Maze Runner</h1>
    <p>Control the ball by tilting your device.</p>
    <p>Complete each level before time runs out.</p>
    <button id="startButton">Start Game</button>
  </div>

  <!-- Level Complete Overlay -->
  <div id="levelCompleteOverlay" class="overlay hidden">
    <h1>Level Complete!</h1>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverOverlay" class="overlay hidden">
    <h1>Game Over!</h1>
    <p>Your Score: <span id="finalScore">0</span></p>
    <button id="restartButton">Restart</button>
  </div>

  <script>
    /************************************
     * Global Variables & Setup
     ************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const levelDisplay = document.getElementById('levelDisplay');
    const timerDisplay = document.getElementById('timerDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    const startOverlay = document.getElementById('startOverlay');
    const startButton = document.getElementById('startButton');
    const levelCompleteOverlay = document.getElementById('levelCompleteOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreDisplay = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');

    let canvasWidth, canvasHeight;
    function resizeCanvas() {
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      // Recalculate current level layout without resetting ball position.
      if (currentLevelData) loadLevel(currentLevelIndex, false);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Game state variables
    let gameState = 'start'; // 'start', 'playing', 'levelComplete', 'gameOver'
    let currentLevelIndex = 0;
    let levels = [];          // Array of level definitions (using relative coordinates)
    let currentLevelData = null;  // Absolute positions for finish area & walls
    let ball = { x: 0, y: 0, radius: 15, vx: 0, vy: 0 };
    let tilt = { x: 0, y: 0 };
    const accelerationFactor = 0.05;
    const friction = 0.98;
    let remainingTime = 10.0;
    let lastTime = 0;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('mazeHighScore')) || 0;
    highScoreDisplay.textContent = highScore;

    /************************************
     * Level Definitions (Relative Coordinates)
     * (Coordinates are fractions of canvas width/height)
     ************************************/
    levels = [
      // Level 1: Simple vertical wall with gap
      {
        start: { x: 0.1, y: 0.1 },
        finish: { x: 0.8, y: 0.8, width: 0.1, height: 0.1 },
        walls: [
          { x: 0.5, y: 0, width: 0.02, height: 0.4 },
          { x: 0.5, y: 0.6, width: 0.02, height: 0.4 }
        ]
      },
      // Level 2: Wall with horizontal obstacle
      {
        start: { x: 0.1, y: 0.1 },
        finish: { x: 0.8, y: 0.8, width: 0.1, height: 0.1 },
        walls: [
          { x: 0.4, y: 0, width: 0.02, height: 0.3 },
          { x: 0.4, y: 0.5, width: 0.02, height: 0.5 },
          { x: 0.2, y: 0.5, width: 0.3, height: 0.02 }
        ]
      },
      // Level 3: Maze with multiple walls
      {
        start: { x: 0.1, y: 0.9 },
        finish: { x: 0.8, y: 0.1, width: 0.1, height: 0.1 },
        walls: [
          { x: 0.3, y: 0, width: 0.02, height: 0.7 },
          { x: 0.3, y: 0.8, width: 0.4, height: 0.02 },
          { x: 0.7, y: 0.3, width: 0.02, height: 0.5 },
          { x: 0.5, y: 0.3, width: 0.2, height: 0.02 }
        ]
      },
      // Level 4: Two vertical walls with gaps
      {
        start: { x: 0.05, y: 0.5 },
        finish: { x: 0.9, y: 0.5, width: 0.07, height: 0.07 },
        walls: [
          { x: 0.3, y: 0, width: 0.02, height: 0.4 },
          { x: 0.3, y: 0.6, width: 0.02, height: 0.4 },
          { x: 0.6, y: 0, width: 0.02, height: 0.6 },
          { x: 0.6, y: 0.7, width: 0.02, height: 0.3 }
        ]
      },
      // Level 5: Central labyrinth
      {
        start: { x: 0.1, y: 0.9 },
        finish: { x: 0.8, y: 0.1, width: 0.08, height: 0.08 },
        walls: [
          { x: 0.2, y: 0.2, width: 0.02, height: 0.6 },
          { x: 0.2, y: 0.2, width: 0.6, height: 0.02 },
          { x: 0.8, y: 0.2, width: 0.02, height: 0.6 },
          { x: 0.2, y: 0.8, width: 0.6, height: 0.02 },
          { x: 0.5, y: 0.2, width: 0.02, height: 0.3 },
          { x: 0.5, y: 0.5, width: 0.02, height: 0.3 }
        ]
      },
      // Level 6: Mixed horizontal and vertical walls
      {
        start: { x: 0.05, y: 0.05 },
        finish: { x: 0.9, y: 0.9, width: 0.07, height: 0.07 },
        walls: [
          { x: 0.3, y: 0, width: 0.02, height: 0.7 },
          { x: 0.6, y: 0.3, width: 0.02, height: 0.7 },
          { x: 0.3, y: 0.7, width: 0.32, height: 0.02 },
          { x: 0.1, y: 0.3, width: 0.2, height: 0.02 }
        ]
      },
      // Level 7: Inverted start/finish with multiple obstacles
      {
        start: { x: 0.9, y: 0.9 },
        finish: { x: 0.05, y: 0.05, width: 0.07, height: 0.07 },
        walls: [
          { x: 0.5, y: 0, width: 0.02, height: 0.5 },
          { x: 0.5, y: 0.6, width: 0.02, height: 0.4 },
          { x: 0.2, y: 0.5, width: 0.4, height: 0.02 },
          { x: 0.2, y: 0.3, width: 0.4, height: 0.02 },
          { x: 0.2, y: 0.3, width: 0.02, height: 0.2 }
        ]
      }
    ];

    /************************************
     * Level & Layout Management
     ************************************/
    // loadLevel recalculates the absolute positions from relative coordinates.
    // If reset is true, it resets the ball to the level's starting point and resets the timer.
    function loadLevel(index, reset = true) {
      const lvl = levels[index];
      if (reset) {
        ball.x = lvl.start.x * canvasWidth;
        ball.y = lvl.start.y * canvasHeight;
        ball.vx = 0;
        ball.vy = 0;
        remainingTime = 10.0;
      }
      levelDisplay.textContent = index + 1;
      scoreDisplay.textContent = score;
      currentLevelData = {
        finish: {
          x: lvl.finish.x * canvasWidth,
          y: lvl.finish.y * canvasHeight,
          width: lvl.finish.width * canvasWidth,
          height: lvl.finish.height * canvasHeight
        },
        walls: lvl.walls.map(w => ({
          x: w.x * canvasWidth,
          y: w.y * canvasHeight,
          width: w.width * canvasWidth,
          height: w.height * canvasHeight
        }))
      };
    }

    /************************************
     * Device Orientation Handling
     ************************************/
    function handleOrientation(event) {
      // event.gamma (left/right tilt), event.beta (front/back tilt)
      tilt.x = event.gamma || 0;
      tilt.y = event.beta || 0;
    }

    /************************************
     * Collision Detection (Circle vs. Rectangle)
     ************************************/
    function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx * dx + dy * dy) < (radius * radius);
    }

    /************************************
     * Game Update & Render Logic
     ************************************/
    function update(delta) {
      // Update ball velocity based on tilt and apply friction
      ball.vx += tilt.x * accelerationFactor;
      ball.vy += tilt.y * accelerationFactor;
      ball.vx *= friction;
      ball.vy *= friction;
      const prevX = ball.x, prevY = ball.y;
      ball.x += ball.vx;
      ball.y += ball.vy;
      // Boundary checks
      if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx = 0; }
      if (ball.x + ball.radius > canvasWidth) { ball.x = canvasWidth - ball.radius; ball.vx = 0; }
      if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy = 0; }
      if (ball.y + ball.radius > canvasHeight) { ball.y = canvasHeight - ball.radius; ball.vy = 0; }
      // Check collisions with each wall
      for (let wall of currentLevelData.walls) {
        if (circleRectCollision(ball.x, ball.y, ball.radius, wall.x, wall.y, wall.width, wall.height)) {
          ball.x = prevX;
          ball.y = prevY;
          ball.vx = 0;
          ball.vy = 0;
          break;
        }
      }
      // Check if ball reaches finish area
      const f = currentLevelData.finish;
      if (ball.x > f.x && ball.x < f.x + f.width &&
          ball.y > f.y && ball.y < f.y + f.height) {
        // Mark level complete
        gameState = 'levelComplete';
        score += 1;
        levelCompleteOverlay.classList.remove('hidden');
        // After a short pause, load the next level (or finish the game)
        setTimeout(() => {
          levelCompleteOverlay.classList.add('hidden');
          currentLevelIndex++;
          if (currentLevelIndex >= levels.length) {
            // If all levels are complete, consider it a win and end the game.
            gameOver(true);
          } else {
            loadLevel(currentLevelIndex);
            gameState = 'playing';
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
          }
        }, 1000);
      }
      // Update countdown timer
      remainingTime -= delta / 1000;
      if (remainingTime <= 0) {
        gameOver(false);
      }
      timerDisplay.textContent = remainingTime.toFixed(1);
    }

    function render() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      // Draw finish area
      const f = currentLevelData.finish;
      ctx.fillStyle = 'lime';
      ctx.fillRect(f.x, f.y, f.width, f.height);
      // Draw walls
      ctx.fillStyle = 'white';
      for (let wall of currentLevelData.walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }
      // Draw the ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = 'red';
      ctx.fill();
      ctx.closePath();
    }

    // Main Game Loop using requestAnimationFrame
    function gameLoop(timestamp) {
      if (gameState !== 'playing') return;
      if (!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime;
      lastTime = timestamp;
      update(delta);
      render();
      requestAnimationFrame(gameLoop);
    }

    /************************************
     * Game Over & Restart Handling
     ************************************/
    function gameOver(win) {
      gameState = 'gameOver';
      finalScoreDisplay.textContent = score;
      // Update high score if needed
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('mazeHighScore', highScore);
        highScoreDisplay.textContent = highScore;
      }
      gameOverOverlay.classList.remove('hidden');
    }

    function restartGame() {
      gameOverOverlay.classList.add('hidden');
      initGame();
    }

    /************************************
     * Game Initialization & Start
     ************************************/
    function initGame() {
      gameState = 'playing';
      currentLevelIndex = 0;
      score = 0;
      loadLevel(currentLevelIndex);
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    // Request device orientation permission (for iOS 13+)
    function startGame() {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(response => {
            if (response === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
              initGame();
            } else {
              alert('Device orientation permission denied.');
            }
          })
          .catch(console.error);
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
        initGame();
      }
    }

    // Event Listeners for Start & Restart Buttons
    startButton.addEventListener('click', () => {
      startOverlay.classList.add('hidden');
      startGame();
    });
    restartButton.addEventListener('click', restartGame);
  </script>
</body>
</html>
